第一章多线程技能
第一节:多线程概述
第二节:使用多线程:
	1.继承Thread类
		实现多线程编程的方式主要有两种,一种是继承Thread类,另一种是实现Runnable接口。
	2.实现Runnable接口
		java中不支持多继承,当一个类中已经有了一个父类,这时不能继承Thread类了,所以需要实现Runnable接口来完成线程任务。	
	3.实例变量与线程安全
		非线程安全主要是指多个线程对同一个对象中的同一个实例变量进行操作时会出现的值被修改,值不同步的情况,进而影响程序的执行流程
		解决方式: 在操作的同一个对象的同一个方法上加上synchronized关键字	
	4.i--与System.out.println的异常
		println方法内部是同步的,当i--的操作进行如println()之前发生的,所以有发生非线程安全问题的概率。
		解决方式:继续使用同步方法	
第三节:currentThread:
	currentThread()方法可返回代码正在被哪个线程调用的信息.	
第四节:isAlive:
	方法isAlive()的功能是判断当前的线程是否处于活动状态
	活动状态:线程已经启动且尚未终止.
	存活:线程处于正在运行或准备开始运行的状态.
第五节:sleep:
	方法sleep()的作用是指定的毫秒数内让当前"正在执行的线程"休眠(暂停执行)		
	这个"正在执行的线程"是指 this.currentThread()返回的线程
第六节:getId:
	getId()方法的作用是取得线程的唯一标识	
第七节:停止线程:
	停止一个线程可以使用Thread.stop()方法,但是最好不用它.这个方法确实可以停止线程,但是这个方法是不安全的.
大多数停止一个线程的操作使用Thread.interrupt()方法,尽管方法的名称是"停止","中止"的意思,但这个方法不会终止
一个正在运行的线程,还需要加入一个判断才可以完成线程的终止.
	1.停止不了的线程
		调用interrupt()方法仅仅是在当前线程中打了一个线程停止的标记,并不是真正的停止线程.
	2.判断线程是否是停止状态
		1) this.interrupted():测试当前线程是否已经是中断状态.执行后具有将状态标识置清除为false的功能
		2) this.isInterrupted():测试线程Thread对象是否已经是中断状态,但不清除状态标志
	3.能停止的线程-异常法
		通过判断线程是否是停止状态,如果是停止状态,则后面的代码不再运行.
		if (this.interrupted()) {throw new InterruptedException();}
	4.在沉睡中停止
		先sleep(20000)在interrupt()停止
		先interrupt()停止在sleep(20000)	
	5.能停止的线程的-暴力停止
		使用stop()方法停止线程则是非常暴力的	
	6.方法stop()与java.lang.ThreadDeath异常
		调用stop()方法时会抛出java.lang.ThreadDeath异常.但是通常情况下此异常不需要显式的捕捉
		方法stop()已经被废弃,因为如果强制让线程停止则有可能使一些清理工作得不到完成,另外一个情况是
		对锁的对象进行了"解锁",导致数据得不到同步的处理.出现数据不一致的问题。
	7.释放锁的不良后果
		使用stop()释放锁将会给数据造成不一致性的结果,如果出现这样的情况,程序处理的数据就有可能遭到破坏,
		最终导致程序执行的流程错误,一定要特别注意.
		由于stop()方法已经在JDK中废除,所以不建议在程序中使用stop()方法.
	8.使用return停止线程
		将方法interrupt()与return结合使用也能实现停止线程的效果.
		while (true) { if (this.interrupted()) { return; } }	
		不过还是建议使用"抛异常"的方法实现程序的停止,因为在catch块中还可以将异常向上抛,使线程停止的事件得以传播.
第八节:暂停线程:
	暂停线程意味着此线程还可以恢复运行,可以使用suspend()方法暂停线程,使用resume()方法恢复线程的执行.
	1.suspend()与resume方法的缺点-独占
		在使用suspend与resume方法时,如果使用不当,极易造成公共的同步对象的独占,使得其他线程无法访问公共同步对象.
	2.suspend()与resume方法的缺点-不同步	
		在使用suspend与resume方法时，容易出现因为线程的暂停而导致的数据不同步的情况
第九节yield:
	yield()方法的作用是放弃当前的CPU资源，将它让其他的任务去占用CPU执行时间，但放弃的时间不确定，有可能刚刚放弃，马上有获得CPU时间片	
第十节:线程的优先级
	线程可以划分为优先级，优先级较高的线程得到的CPU资源较多，也就是CPU优先执行优先级较高的线程对象中的任务
    设置优先级有助于帮助"线程规划器" 确定在下一次选择哪一个线程来优先执行
    设置线程的优先级使用setPriority()方法
	在JDK中，线程优先级分为1—10 这10个级别，如果小于1或大于10，则JDK抛出异常throw new IllegelArgumentException()。
	JDK 中 使用 3个变量来定义优先级的值，代码如下：
		public final static int MIN_PRIORITY = 1;
		public final static int NORM_PRIORITY = 5;
		public final static int MAX_PRIORITY = 10;	
	1.线程优先级的继承性
		优先级具有继承性，比如A线程启动B线程，则B线程的优先级与A是一样的
	2.优先级具有规则性	
		虽然使用setPriority()方法 可以设置线程的优先级，但还没有看到设置优先级所带来的效果	
		线程优先级与代码块执行顺序无关，出现这样的结果因为设置优先级的大小，说明线程优先级具有一定的规则性，也就是CPU尽量
		将执行资源让给优先级高的线程。
	3.优先级具有随机性
		前面例子介绍了线程的优先级较高则优先执行完run() 方法中的任务，但这个结果不能说的太肯定，因为线程的优先级还具有"随机性",也就是优先级较高的线程不一定每一次都先执行完。
		结论:不要把线程的优先级与运行结果的顺序作为衡量的标准，优先级较高的线程不一定每一次都先执行完run()方法中任务，
		也就是说，线程的优先级与打印的顺序无关，不要将这两者的关系相关联，它们的关系具有不确定性和随机性。
	4.看谁运行快
		优先级高的运行快
第十一节:守护线程:
		守护线程是一种特殊的线程，它的特性有“陪伴”的含义，当线程中不存在非守护线程了，则守护线程自动销毁。
	典型的守护线程就是垃圾回收线程，当进程中没有非守护线程了，则垃圾回收线程也就没有存在的必要了，自动销毁。
	用个比较通俗的比喻来解释下“守护线程”：任何一个守护线程都是整个JVM中所有非守护线程的“保姆”，只要当前JVM
	实例中存在任何一个非守护线程没有结束，守护线程就在工作，只有当最后一个非守护线程了，则垃圾回收线程也就没有
	存在的必要了，自动销毁。
	只要当前线程中存在任何一个非守护线程没有结束，守护线程就在工作。
	只有当最后一个非守护线程结束时，守护线程才随着JVM一同结束工作。
	Daemon的作用是为其它线程的运行提供便利的服务，守护线程最典型的应用就是GC(垃圾回收器)。	
	
	
	
	
	
	
		
		
		