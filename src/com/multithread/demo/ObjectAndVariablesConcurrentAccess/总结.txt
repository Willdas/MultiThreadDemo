第二章对象及变量的并发访问
第一节:synchronized同步方法:
	1.方法内的变量为线程安全
		"非线程安全" 问题存在于"实例变量"中,如果是方法内部的私有变量，则不存在"非线程安全"问题,所得结果也就是"线程安全"的了
	这是方法内部的变量是私有的特性造成的。
	
	2.实例变量非线程安全
		如果多个线程共同访问同一个对象中非同步的方法并且操作的是实例变量,则有可能出现"非线程安全"问题。
	只有在多个线程访问同一个对象中的同步方法时实例变量才是线程安全的。(需要在被操作的对象方法上加synchronized关键字)
	
	3.多个对象多个锁
		关键字synchronized取得的锁都是对象锁,而不是把一段代码或方法(函数)当做锁,所以哪个线程先
	执行带synchronized关键字的方法,哪个线程就是持有该方法所属对象的锁lock,那么其它线程只能呈等待状态,前提
	是多个线程访问的是同一个对象.
		但如果多个线程访问多个对象,则JVM会创建多个锁.
	同步的单词是synchronized 异步的单词是asynchronized
	
	4.synchronized方法与锁对象
		调用关键字synchronized申明的方法一定是排队运行的。另外需要牢牢记住"共享"这两个字,
	注：只有共享资源的读写访问才需要同步化,如果不是共享资源,那么根本就没有同步的必要.
		A线程先持有object对象的Lock锁,B线程可以以异步的方式调用object对象中的非synchroniezd类型的方法
		A线程先持有object对象的Lock锁,B线程如果在这时调用object对象中的synchronized类型的方法则需等待,也就是同步.
	
	5.脏读
	    原因:
		当A线程调用anyObject对象加入synchronized关键字的X方法时,A线程就获得了X方法锁,
	更准确的说,是获得了对象的锁,所以其它线程必须等A线程执行完毕
	才可以调用X方法,但B线程可以随意调用其它的非synchronized同步方法
		解决方式:(在需要获取实例变量的非X方法上也加上synchronized关键字)
		当A线程调用anyObject对象加入synchronized关键字的X方法时,A线程就获得了X方法所在对象的锁,所以其它线程必须等A线程执行完毕才可以调用X方法,
	而B线程如果调用申明了synchronized关键字的非X方法时,必须等A线程将X方法执行完,也就是释放对象锁后才可以调用,这时A线程已经执行了一个完整的
	任务,也就是说username和password这两个实例变量已经同时被赋值,不存在脏读的基本环境.
	注: 脏读一定会出现在操作实例变量的情况下,这就是不同线程"争抢"实例变量的结果.
	
	6.synchronized锁重入
		关键字synchronized拥有锁重入的功能,也就是在使用synchronized时,当一个线程得到一个对象锁时,再次请求该对象时是可以再次得到该对象的锁的.
	这也证明synchronized方法/块的内部本类的其它synchronized方法/块时,是永远可以得到锁的。
		可重入锁的概念:
		自己可以再次获取自己的内部锁.
	比如有1条线程获得了某个对象的锁,此时这个对象锁还没有释放,当其再次想要获得这个对象的锁的时候还是可以
	获取的,如果不可重入的话,就会造成死锁.
	可重入锁也支持在父类继承的环境中.
	
	7.出现异常,锁自动释放	
		当一个线程执行的代码出现异常时,其所持有的锁会被释放.
	
	8.同步不具有继承性
		同步不可以继承(要想同步需要在父类和子类的方法上都加上synchronized关键字)
第二节:synchronized同步语句块:
		用关键字synchronized声明方法的某些情况下是有弊端的,比如A线程调用同步方法执行一个长时间的任务,那么B线程
	则必须等待比较长的时间,在这样的情况下可以使用synchronized同步语句块来解决.
	1.synchronized方法的弊端
	2.synchronized同步代码块的使用
			当两个并发线程访问同一个对象object的synchronized(this)同步代码块时,一段时间内只有一个线程
		被执行,另一个线程必须等待当前线程执行完这个代码块以后才能执行该代码块.	
	3.用同步代码块解决同步方法的弊端
			当一个线程访问object中的一个synchronized同步代码块时,另一个线程仍然可以访问该object对象中的非synchronized(this)同步代码块
		虽然用时缩短,运行效率加快,但同步synchronized代码块真的同步吗？真的持有当前调用的对象的锁吗?答案为是.	
	4.一半同步,一半异步
		不在synchronized块中的就是异步代码,在synchronized中的就是同步代码	
	5.synchronized代码块间的同步性
			在使用同步synchronized(this)代码块时需要注意的是,当一个线程访问object的一个synchronized(this)同步
		代码块时,其它线程对同一个object中所有其它synchronized(this)同步代码块的访问将被阻塞,
		这说明synchronized使用的是一个"对象监视器".	
	6.验证同步synchronized(this)代码块是锁定当前对象的	
	7.将任意对象作为对象监视器
		多个线程调用同一个对象中的不同名称的synchronized同步方法或synchronized(this)同步代码块时,调用的效果就是按照顺序执行,也就是同步的,阻塞的.
		这说明synchronized同步方法或synchronized(this)同步代码块的调用呈阻塞状态.
			(1)synchronized同步方法
				1) 对其他synchronized同步方法或synchronized(this)同步代码块调用呈阻塞状态
				2) 同一时间只有一个线程可以执行synchronized同步方法中的代码
			(2)synchronized(this)同步代码块
				1) 对其他synchronized同步方法或synchronized(this)同步代码块调用呈阻塞状态
				2) 同一时间只有一个线程可以执行synchronized(this)同步代码块中的代码
			除了使用synchronized(this)格式来同步代码块,其实java还支持对"任意对象"作为"对象监视器"来实现同步的功能.
			这个"任意对象"大多数是实例变量及方法的参数,使用格式为synchronized(非this对象).
			根据前面对synchronized(this)同步代码块的作用总结可知,synchronized(非this对象)格式的作用只有1种:synchronized(非this对象)同步代码块
				1) 在多个线程持有"对象监视器"为同一个对象前提下,同一时间只有一个线程可以执行synchronized(非this对象)同步代码块中的代码.
				2) 当持有"对象监视器"为同一个对象的前提下,同一时间只有一个线程可以执行synchronized(非this对象)同步代码块中的代码.
			锁非this对象具有一定的优点:如果在一个类中有很多个synchronized方法,这时虽然能实现同步,但会受到阻塞,所以影响效率;但如果使用同步代码块
			锁非this对象,则synchronized(非this)代码块中的程序与同步方法是异步的,不与其他锁this同步方法争抢this锁,则可以大大提高运行效率.	
		使用"synchronized(非this对象x)同步代码块"格式化进行同步操作时,对象监视器必须是同一个对象.如果不是同一个
	 	监视器,运行的结果就是异步调用了,就会出现交叉运行.
		使用"synchronized(非this对象x)同步代码块"格式时,持有不同的对象监视器是异步的效果.
	 	也就是说:synchronized(非this对象)与同步synchronized方法是异步调用的效果.
	 	由于对象监视器不同,所以运行结果就是异步的.
		同步代码块放在非同步synchronized方法中进行声明,并不能保证调用方法的线程的执行同步/顺序读,也就是
		线程调用的顺序是无序的,虽然在同步块中执行的顺序是同步的,这样极易出现"脏读"问题.
		解决方式:
			使用"synchronized(非this对象x)同步代码块"格式也可以解决"脏读"问题.
		验证多个线程调用同一个方法是随机的   
	 		由于线程执行的顺序是不确定的,所以当线程A和线程B的执行带有分支判断的方法时,就会出现逻辑上的错误,有可能出现脏读.
		验证多个线程调用同一个方法是随机的   
	 		由于线程执行的顺序是不确定的,所以当线程A和线程B的执行带有分支判断的方法时,就会出现逻辑上的错误,有可能出现脏读.
			解决方式:同步化 修改MyService方法加上synchronized关键字并且对myOnlist进行同步
	8.细化验证3个结论
		"synchronized(非this对象x)"格式的写法是将x对象本身作为"对象监视器",这样就可以得出以下3个结论
		1) 当多线程同时执行synchronized(x){} 同步代码块时呈同步效果;
		2) 当	其他线程执行x对象中的synchronized同步方法时呈同步效果;
		3) 当其他线程执行x对象方法里面的synchronized(this)代码块时也呈现同步效果
		但需要注意:如果其他线程调用不加synchronized关键字的方法时,还是异步调用.	
	9.静态同步synchronized 方法与synchronized(class) 代码块
		1)关键字synchronized还可以应用在static静态方法上,如果这样写,那是对当前的*.java文件对应的Class类进行持锁
 		区别:
			synchronized加到静态方法上和synchronized加到非静态方法上的区别
			synchronized关键字加到static静态方法上是给Class类上锁,而synchronized关键字加到非static静态方法上是给对象上锁.
	 	2)关键字synchronized还可以应用在static静态方法上,如果这样写,那是对当前的*.java文件对应的Class类进行持锁
			验证synchronized加到静态方法上和synchronized加到非静态方法上 不是同一个锁
			出现异步的原因:因为持有不同的锁,一个是对象锁,一个是Class锁,而Class锁可以对类的所有对象实例起作用
		3)关键字synchronized还可以应用在static静态方法上,如果这样写,那是对当前的*.java文件对应的Class类进行持锁
			验证 Class锁可以对类的所有对象实例起作用
		4)同步synchronized(class)代码块的作用其实和synchronized static 方法的作用一样.
	10.数据类型String的常量池特性
	 	1)将synchronized(sting) 同步块与String联合使用时,要注意常量池以带来的一些例外
		 	出现此情况的原因:String的两个值都是AA,两个线程持有相同的锁,所以造成B不能执行.这就是String常量池锁带来的问题.
		  	因此大多数情况下，同步synchronized代码块都不能使用String作为锁对象,而是改用其他.
		 	比如new Object()实例化一个Object对象,但它并不放入缓存中.
		2)大多数情况下，同步synchronized代码块都不能使用String作为锁对象,而是改用其他.
	 		比如new Object()实例化一个Object对象,但它并不放入缓存中.这样持有的锁不是一个
	11.同步synchronized方法无限等待与解决
		1)同步方法容易造成死循环
			解决方式:使用同步块来解决
	12.多线程的死锁
		Java线程死锁是一个经典的多线程问题,因为不同的线程都在等待根本不可能被释放的锁,从而导致所有的任务都无法继续
		完成.在多线程技术中,"死锁"是必须避免的,因为这会造成线程的"假死"
		使用JDK自带工具检测死锁：
			(1)首先进入cmd窗口,再次进入jdk安装目录下的bin目录下
			(2)输入jps,回车,得到Run的id值
			(3)jstack -l id值  
			(4)在末尾处可以看到死锁的信息
	13.内置类与静态内置类
	14.内置类与同步:实验1
		此案例中有两个同步方法,但使用的却是不同的锁(也就是不同的"对象监视器") 结果也是异步(乱序)
	15.内置类与同步:实验2
		此案例中,同步代码块synchronized(class2)对class2上锁后,其它线程只能以同步的方式调用class2中的静态同步方法.		
	16.锁对象的改变
		1)在将任何数据类型作为同步锁时,需要注意的是,是否有多个线程同时持有锁对象,如果同时持有相同的锁对象,
			则这些线程之间就是同步的,如果分别获得锁对象,这些线程之间就是异步的.		
		2)在将任何数据类型作为同步锁时,需要注意的是,是否有多个线程同时持有锁对象,如果同时持有相同的锁对象,
			则这些线程之间就是同步的,如果分别获得锁对象,这些线程之间就是异步的.
			只要对象不变,即使对象的属性被改变,运行的结果还是同步	
第三节:volatile关键字
	1.关键字volatile与死循环
		当main线程一直处于while()循环中时,导致程序不能继续执行后面的代码,解决的办法是用多线程技术.
	2.解决同步死循环
		关键字volatile的作用是强制从公共堆栈中取得变量的值,而不是从线程私有数据栈中取得变量的值
   		解决方法:使用volatile关键字
	3.解决异步死循环
		使用volatile关键字增加了实例变量在多个线程之间的可见性.但volatile关键字最致命的缺点是不支持原子性.	
		下面将关键字synchronized和volatile进行一下比较:
			1)关键字volatile是线程同步的轻量级实现,所以volatile性能肯定比synchronized要好,并且volatile只能修饰于变量，而synchronized可以修饰方法,以及代码块,随着JDK新版本的发布,synchronized关键字在执行效率上得到很大的提升,在开发中使用synchronized关键字的比率还是比较大的.
			2)多线程访问volatile不会发生阻塞,而synchronized会出现阻塞.
			3)volatile能保证数据的可见性,但不能保证原子性,而synchronized可以保证原子性,也可以间接的保证可见性,因为它会将私有内存和公共内存中的数据做同步
			4)再次重申一下,关键字volatile解决的是变量在多个线程之间的可见性,而synchronized关键字解决的是多个线程之间的访问资源的同步性.
		线程安全包含原子性和可见性两个方面:java的同步机制都是围绕这两个方面来确保线程安全的.
	4.volatile非原子的特性
		关键字volatile虽然增加了实例变量在多个线程之间可见性,但它却不具备同步性,那么也就不具备原子性.	
		关键字volatile主要使用的场合是在多个线程中可以感知实例变量的被个更改了,并且可以获得最新的值使用,也就是用多线程读取共享变量时可以获得最新值使用.
		关键字volatile提示线程每次从共享内存中读取变量,而不是从私有内存中读取,这样就保证了同步数据的可见性.
		但在这里需要注意的是:如果修改实例变量中的数据,比如:i++;也就是i=i+1,则这样的操作其实并不是一个原子操作,也就是非线程安全.
		关键字volatile本身并不处理数据的原子性,而是强制对数据的读写及时影响到主内存.
		对于volatile修饰的变量,JVM虚拟机只是保证从主内存加载到线程工作内存的值是最新的.
		关键字volatile解决的是变量读时的可见性问题,但无法保证原子性,对于多个线程访问同一个实例变量还是需要加锁同步.	
	5. 使用原子类进行i++操作
		在操作i++时除了使用synchronized关键字之外,还可以使用AtomicInteger原子类进行实现
  		原子操作时不可分割的整体,没有其他线程能够中断或者检查正在原子操作中的变量.
  		一个原子(atomic)类型就是一个原子操作可用的类型,它可以在没有锁的情况下做到线程安全(thread-safe)	
	6.原子类也并不完全安全
		原子类在具有逻辑性的情况下输出结果也具有随机性.
		解决方式:加上synchronized
	7. synchronized代码块有volatile同步的功能	
		关键字synchronized可以使用多个线程访问同一个资源具有同步性,而且它还具有将线程工作内存中的私有变量与公共内存中的变量同步的功能.
		关键字synchronized可以保证在同一时刻,只有一个线程可以执行某一个方法或某一个代码块.
		它包含两个特征:互斥性和可见性.
		同步synchronized不仅可以解决一个线程看到的对象处于不一致的状态,还可以保证进入同步方法或者
		同步代码块的每个线程,都看到由同一个锁保护之前所有的修改效果.
				
			
			
			
			
			
			
			
			
			
			
			
			
			
			

