volatile关键字
	1.关键字volatile与死循环
		当main线程一直处于while()循环中时,导致程序不能继续执行后面的代码,解决的办法是用多线程技术.
	2.解决同步死循环
		关键字volatile的作用是强制从公共堆栈中取得变量的值,而不是从线程私有数据栈中取得变量的值
   		解决方法:使用volatile关键字
	3.解决异步死循环
		使用volatile关键字增加了实例变量在多个线程之间的可见性.但volatile关键字最致命的缺点是不支持原子性.	
		下面将关键字synchronized和volatile进行一下比较:
			1)关键字volatile是线程同步的轻量级实现,所以volatile性能肯定比synchronized要好,并且volatile只能修饰于变量，而synchronized可以修饰方法,以及代码块,随着JDK新版本的发布,synchronized关键字在执行效率上得到很大的提升,在开发中使用synchronized关键字的比率还是比较大的.
			2)多线程访问volatile不会发生阻塞,而synchronized会出现阻塞.
			3)volatile能保证数据的可见性,但不能保证原子性,而synchronized可以保证原子性,也可以间接的保证可见性,因为它会将私有内存和公共内存中的数据做同步
			4)再次重申一下,关键字volatile解决的是变量在多个线程之间的可见性,而synchronized关键字解决的是多个线程之间的访问资源的同步性.
		线程安全包含原子性和可见性两个方面:java的同步机制都是围绕这两个方面来确保线程安全的.
	4.volatile非原子的特性
		关键字volatile虽然增加了实例变量在多个线程之间可见性,但它却不具备同步性,那么也就不具备原子性.	
		关键字volatile主要使用的场合是在多个线程中可以感知实例变量的被个更改了,并且可以获得最新的值使用,也就是用多线程读取共享变量时可以获得最新值使用.
		关键字volatile提示线程每次从共享内存中读取变量,而不是从私有内存中读取,这样就保证了同步数据的可见性.
		但在这里需要注意的是:如果修改实例变量中的数据,比如:i++;也就是i=i+1,则这样的操作其实并不是一个原子操作,也就是非线程安全.
		关键字volatile本身并不处理数据的原子性,而是强制对数据的读写及时影响到主内存.
		对于volatile修饰的变量,JVM虚拟机只是保证从主内存加载到线程工作内存的值是最新的.
		关键字volatile解决的是变量读时的可见性问题,但无法保证原子性,对于多个线程访问同一个实例变量还是需要加锁同步.	
	5. 使用原子类进行i++操作
		在操作i++时除了使用synchronized关键字之外,还可以使用AtomicInteger原子类进行实现
  		原子操作时不可分割的整体,没有其他线程能够中断或者检查正在原子操作中的变量.
  		一个原子(atomic)类型就是一个原子操作可用的类型,它可以在没有锁的情况下做到线程安全(thread-safe)	
	6.原子类也并不完全安全
		原子类在具有逻辑性的情况下输出结果也具有随机性.
		解决方式:加上synchronized
	7. synchronized代码块有volatile同步的功能	
		关键字synchronized可以使用多个线程访问同一个资源具有同步性,而且它还具有将线程工作内存中的私有变量与公共内存中的变量同步的功能.
		关键字synchronized可以保证在同一时刻,只有一个线程可以执行某一个方法或某一个代码块.
		它包含两个特征:互斥性和可见性.
		同步synchronized不仅可以解决一个线程看到的对象处于不一致的状态,还可以保证进入同步方法或者
		同步代码块的每个线程,都看到由同一个锁保护之前所有的修改效果.
		
		
		
		
		
		
		
		
		
		
		
		
		
		