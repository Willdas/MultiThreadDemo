同步方法:
	1.方法内的变量为线程安全
		"非线程安全" 问题存在于"实例变量"中,如果是方法内部的私有变量，则不存在"非线程安全"问题,所得结果也就是"线程安全"的了
	这是方法内部的变量是私有的特性造成的。
	
	2.实例变量非线程安全
		如果多个线程共同访问同一个对象中非同步的方法并且操作的是实例变量,则有可能出现"非线程安全"问题。
	只有在多个线程访问同一个对象中的同步方法时实例变量才是线程安全的。(需要在被操作的对象方法上加synchronized关键字)
	
	3.多个对象多个锁
		关键字synchronized取得的锁都是对象锁,而不是把一段代码或方法(函数)当做锁,所以哪个线程先
	执行带synchronized关键字的方法,哪个线程就是持有该方法所属对象的锁lock,那么其它线程只能呈等待状态,前提
	是多个线程访问的是同一个对象.
		但如果多个线程访问多个对象,则JVM会创建多个锁.
	同步的单词是synchronized 异步的单词是asynchronized
	
	4.synchronized方法与锁对象
		调用关键字synchronized申明的方法一定是排队运行的。另外需要牢牢记住"共享"这两个字,
	注：只有共享资源的读写访问才需要同步化,如果不是共享资源,那么根本就没有同步的必要.
		A线程先持有object对象的Lock锁,B线程可以以异步的方式调用object对象中的非synchroniezd类型的方法
		A线程先持有object对象的Lock锁,B线程如果在这时调用object对象中的synchronized类型的方法则需等待,也就是同步.
	
	5.脏读
	    原因:
		当A线程调用anyObject对象加入synchronized关键字的X方法时,A线程就获得了X方法锁,
	更准确的说,是获得了对象的锁,所以其它线程必须等A线程执行完毕
	才可以调用X方法,但B线程可以随意调用其它的非synchronized同步方法
		解决方式:(在需要获取实例变量的非X方法上也加上synchronized关键字)
		当A线程调用anyObject对象加入synchronized关键字的X方法时,A线程就获得了X方法所在对象的锁,所以其它线程必须等A线程执行完毕才可以调用X方法,
	而B线程如果调用申明了synchronized关键字的非X方法时,必须等A线程将X方法执行完,也就是释放对象锁后才可以调用,这时A线程已经执行了一个完整的
	任务,也就是说username和password这两个实例变量已经同时被赋值,不存在脏读的基本环境.
	注: 脏读一定会出现在操作实例变量的情况下,这就是不同线程"争抢"实例变量的结果.
	
	6.synchronized锁重入
		关键字synchronized拥有锁重入的功能,也就是在使用synchronized时,当一个线程得到一个对象锁时,再次请求该对象时是可以再次得到该对象的锁的.
	这也证明synchronized方法/块的内部本类的其它synchronized方法/块时,是永远可以得到锁的。
		可重入锁的概念:
		自己可以再次获取自己的内部锁.
	比如有1条线程获得了某个对象的锁,此时这个对象锁还没有释放,当其再次想要获得这个对象的锁的时候还是可以
	获取的,如果不可重入的话,就会造成死锁.
	可重入锁也支持在父类继承的环境中.
	
	7.出现异常,锁自动释放	
		当一个线程执行的代码出现异常时,其所持有的锁会被释放.
	
	8.同步不具有继承性
		同步不可以继承(要想同步需要在父类和子类的方法上都加上synchronized关键字)


